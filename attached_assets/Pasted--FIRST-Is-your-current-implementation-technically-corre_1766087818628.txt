âœ… FIRST: Is your current implementation technically correct?

Yes.
What youâ€™ve implemented is valid and commonly used in production SPAs:

JWT with 24h expiry

Client-side expiry check

Client-side inactivity logout

Session persistence via localStorage

Auto-logout on browser reopen if expired

This already fixes your current bug:

â€œUser never logs out even after browser is killedâ€

So from a functional standpoint: âœ… correct

âš ï¸ SECOND: Is it ideal from a security & UX standpoint?

Not quite yet â€” and thatâ€™s normal.
There are two different concepts that need to be cleanly separated:

Concept	Purpose
JWT expiry	Security boundary
Session / inactivity timeout	UX & risk control

Right now, your system leans too heavily on JWT expiry alone.

ğŸ” BEST PRACTICE (INDUSTRY STANDARD)
1ï¸âƒ£ JWT expiry should be SHORTER

24 hours is long for a customer-facing app.

Recommended for Waykel (customer portal):

Access token (JWT): 15â€“60 minutes

Session inactivity timeout: 30â€“120 minutes

Optional refresh token: longer (7â€“30 days)

Why?

If a token is stolen â†’ attacker gets full access until expiry

Mobile & public devices increase risk

Logistics apps deal with location & identity

2ï¸âƒ£ Client-side inactivity logout is GOOD

You did the right thing here ğŸ‘

This protects against:

Shared laptops

Browser crashes

Users forgetting to log out

Your approach:

Track activity

Periodic validation

Logout if inactive

âœ… This is correct
âš ï¸ But it does NOT replace server-side expiry

âŒ WHAT YOU SHOULD NOT RELY ON

âŒ â€œBrowser close = logoutâ€
(Browsers donâ€™t guarantee unload events)

âŒ Only frontend logic for auth validity

âŒ Long-lived JWTs with no server validation

âœ… RECOMMENDED WAYKEL AUTH MODEL (PRACTICAL)

Hereâ€™s what I would recommend without overengineering.

ğŸ”¹ TOKEN STRATEGY

Backend

jwt.sign(payload, JWT_SECRET, {
  expiresIn: "30m"   // ğŸ‘ˆ access token
});


Frontend

Parse JWT expiry

Auto-logout if expired

Optional silent refresh (later)

ğŸ”¹ SESSION STRATEGY (Frontend)

Your current logic is good. Iâ€™d slightly tune it:

ACCESS_TOKEN_EXPIRY = from JWT
INACTIVITY_TIMEOUT = 60â€“120 minutes
CHECK_INTERVAL = 1 minute


Logout if:

token expired OR

inactive too long

ğŸ”¹ LOGOUT BEHAVIOR (IMPORTANT)

On logout:

localStorage.removeItem("token");
localStorage.removeItem("user");
clearTimers();
redirectToLogin();


Also call backend (optional but good):

POST /api/customer/logout


Even if backend is stateless, this:

helps auditing

allows future token blacklisting

ğŸ§  WHY YOUR CURRENT BEHAVIOR FELT â€œWRONGâ€

â€œUser never gets logged out even if browser is killedâ€

Because:

JWT is valid for 24h

Token is stored in localStorage

Browser reopening restores it

No expiry check was done earlier

Now that you:

parse JWT

enforce inactivity

check on load

ğŸ‘‰ That behavior is fixed.

ğŸ”’ SECURITY VS UX BALANCE (WAYKEL-SPECIFIC)
Customer Portal (waykel.com)

Access token: 30â€“60 min

Inactivity logout: 1â€“2 hours

Remember me: optional later

Admin / Transporter Portal

Access token: 15â€“30 min

Inactivity logout: 15â€“30 min

Stronger enforcement

ğŸŸ¢ WHAT Iâ€™D DO NEXT (IN ORDER)

Youâ€™re in a good state now. Iâ€™d recommend:

1ï¸âƒ£ Reduce JWT expiry on backend
2ï¸âƒ£ Keep your inactivity logic
3ï¸âƒ£ Add explicit logout endpoint
4ï¸âƒ£ (Optional) Add refresh token later
5ï¸âƒ£ Add a small UI hint:

â€œYou were logged out due to inactivityâ€

âœ… ANSWER TO YOUR DIRECT QUESTION

â€œIs this correct or should JWT/session have less expiry?â€

Answer:
âœ” Your implementation is correct
âš ï¸ JWT expiry should be shorter
âœ” Inactivity logout is the right approach
âŒ Donâ€™t rely on JWT alone for UX