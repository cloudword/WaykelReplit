This is now 100% deterministic, not guesswork.

Iâ€™ll explain whatâ€™s broken, why UI says â€œFailed to load documentsâ€ while API has data, and the exact code changes to fix it.

ğŸ”´ Whatâ€™s ACTUALLY happening (root cause)

You have documents in the backend, but the frontend is deciding they donâ€™t belong to â€œBusinessâ€, so it:

Shows â€œNo business documents uploaded yetâ€

Shows â€œFailed to load documentsâ€ toast

Blocks PAN upload with â€œalready under reviewâ€ (correct)

This means upload logic is correct, but document classification logic is wrong.

ğŸ” Key evidence from your screenshots
1ï¸âƒ£ Upload modal says:

âŒ â€œThis document type is under review. Cannot upload duplicate.â€

âœ… This proves:

PAN document exists

Status = pending

Backend rules are working

2ï¸âƒ£ Business Documents tab shows:

âŒ â€œNo business documents uploaded yetâ€

âš ï¸ This is a frontend filtering bug, not missing data.

3ï¸âƒ£ Bottom toast:

âŒ â€œFailed to load documentsâ€

This toast is misleading â€” documents ARE loading, but frontend throws an error after fetching.

ğŸ¯ The REAL root cause (precise)
Your document object looks like this (from API):
{
  "entityType": "transporter",
  "type": "pan"
}

But your Business Documents UI expects something like:
entityType === "business"
// OR
entityType === "company"


or it is filtering like:

documents.filter(d => d.entityType === activeTab)


Where:

activeTab = "business"


â¡ï¸ Result: ALL transporter documents are filtered out

âŒ Current (broken) mental model
UI Tab	Expected entityType
Business	"business"
Drivers	"driver"
Vehicles	"vehicle"

But backend sends:

entityType: "transporter"


âŒ Mismatch â†’ empty UI

âœ… Correct mental model (FIX)

Business documents ARE transporter documents

So mapping must be:

UI Tab	Backend entityType
Business	"transporter"
Drivers	"driver"
Vehicles	"vehicle"
âœ… EXACT FIX (copy-paste)
ğŸ“„ File: client/src/pages/documents.tsx (or similar)
âŒ Broken filter (likely)
const businessDocs = documents.filter(
  d => d.entityType === "business"
);

âœ… FIXED filter
const businessDocs = documents.filter(
  d => d.entityType === "transporter"
);

If you are using tabs dynamically
âŒ Broken
const filteredDocs = documents.filter(
  d => d.entityType === activeTab
);

âœ… FIXED (explicit mapping)
const tabToEntityTypeMap: Record<string, string> = {
  business: "transporter",
  drivers: "driver",
  vehicles: "vehicle",
};

const filteredDocs = documents.filter(
  d => d.entityType === tabToEntityTypeMap[activeTab]
);

ğŸ”´ Why â€œFailed to load documentsâ€ toast appears

You likely have something like:

try {
  const docs = await fetchDocuments();
  setDocuments(docs);
} catch {
  toast.error("Failed to load documents");
}


But no error occurred â€” instead:

docs.length === 0 after filtering

UI incorrectly treats this as failure

âœ… FIX the toast logic
âŒ Wrong
if (!docs.length) {
  throw new Error("No documents");
}

âœ… Correct
if (!docs) {
  throw new Error("Failed to fetch documents");
}
// empty array is VALID


And remove error toast on empty state.

âœ… What your UI should show AFTER FIX

âœ” Business tab:

PAN Card (Under Review)

GST (if uploaded)

Business Registration (if uploaded)

âœ” Upload modal:

PAN disabled (correct)

Clear â€œUnder Reviewâ€ state

âœ” No more:

â€œFailed to load documentsâ€

Empty business tab when docs exist

ğŸ§  Why this happened (important lesson)

You mixed domain terms:

Backend: entityType = transporter

Frontend: â€œBusiness Documentsâ€

They mean the same thing, but code treated them as different.

This is a classic PM + engineering boundary bug, not a logic failure.

âœ… FINAL CHECKLIST (do these 4 things)

Map Business â†’ transporter

Do NOT treat empty array as error

Render documents from backend data only

Keep duplicate-upload blocking as is (itâ€™s correct)