Whatâ€™s happening (root cause)

Your API endpoint:

POST /api/spaces/upload


is throwing a 500 error with:

"transporterId required for transporter documents"


The stack trace points to:

getDocumentStoragePath (/workspace/dist/index.cjs:45520)

Meaning in plain English

Your upload logic has document-typeâ€“based storage rules.

For transporter documents, your backend expects a transporterId, but the request does not contain it.

So when the backend tries to compute the storage path (likely something like):

/spaces/transporter/{transporterId}/documents/...


â€¦it fails because transporterId is undefined.

Why /api/health is fine

This confirms:

App is running

DB is connected

Express is healthy

So this is not infra, not DB, not deployment
ğŸ‘‰ Itâ€™s a request validation / API contract issue

Where the failure happens (important)

This line is key:

Error: transporterId required for transporter documents
at getDocumentStoragePath


That means:

Validation is happening inside storage-path resolution

Not at request validation layer (Zod/Joi/middleware)

So bad requests are reaching deep logic â†’ causing 500s âŒ

What you should fix (3 levels)
âœ… Fix 1: Ensure frontend / client sends transporterId

If the document type is transporter-related, your request must include:

Example request (multipart)
POST /api/spaces/upload
Content-Type: multipart/form-data

{
  "documentType": "TRANSPORTER_DOC",
  "transporterId": "tr_123456",
  "file": <binary>
}


If youâ€™re using FormData in frontend:

const formData = new FormData();
formData.append("file", file);
formData.append("documentType", "TRANSPORTER_DOC");
formData.append("transporterId", transporterId); // REQUIRED


ğŸš¨ If transporterId is missing â†’ this error is expected.

âœ… Fix 2: Validate earlier (recommended)

Right now, your backend throws this too late.

Add validation before calling getDocumentStoragePath.

Example (Express middleware)
if (documentType === "TRANSPORTER_DOC" && !transporterId) {
  return res.status(400).json({
    error: "transporterId is required for transporter documents"
  });
}


This converts:

âŒ 500 Internal Server Error

âœ… 400 Bad Request (correct behavior)

âœ… Fix 3: Make document types explicit (best practice)

If you donâ€™t already have this, define a clear rule:

documentType	Required IDs
TRANSPORTER_DOC	transporterId
VEHICLE_DOC	vehicleId
DRIVER_DOC	driverId
GENERAL	none

Then enforce centrally:

const REQUIRED_IDS = {
  TRANSPORTER_DOC: "transporterId",
  VEHICLE_DOC: "vehicleId",
  DRIVER_DOC: "driverId"
};

const requiredField = REQUIRED_IDS[documentType];

if (requiredField && !req.body[requiredField]) {
  return res.status(400).json({
    error: `${requiredField} required for ${documentType}`
  });
}

Why this matters (PM + backend perspective)

Since youâ€™re a Product Manager with strong tech depth, this is important:

This is an API contract mismatch

Frontend + backend assumptions are misaligned

500 errors here will:

Break uploads silently

Confuse users

Pollute error logs

Mask real infra issues

ğŸ‘‰ This should be treated as a P1 API correctness fix, not just a bug.

TL;DR

âŒ Error is not infra or DB

âŒ Backend expects transporterId but request doesnâ€™t send it

âœ… Send transporterId from client

âœ… Add early validation â†’ return 400, not 500

âœ… Centralize document-type â†’ required-ID mapping